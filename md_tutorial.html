<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>uatlib: Tutorial</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="icon.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">uatlib
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Tutorial </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This tutorial is a step-by-step guide to creating a simple simulation of a first-price sealed-bid auction using <code>uatlib</code>. Each agent in the simulation bids for permits to use a certain region of the airspace for a certain period of time.</p>
<p><code>uatlib</code> is a C++ library that enables users to describe the rules of the airspace and the behavior of the agents in the simulation. The library provides a simulation engine that can be used to run the simulation and analyze the results.</p>
<h1><a class="anchor" id="autotoc_md4"></a>
Getting started</h1>
<p><code>uatlib</code> uses CMake to build the library and link it with the user's code.</p>
<p>To get started, create a new directory for the tutorial and initialize a Git repository:</p>
<div class="fragment"><div class="line">mkdir uatlib-tutorial</div>
<div class="line">cd uatlib-tutorial</div>
<div class="line">git init</div>
</div><!-- fragment --><p>Now, let's add <code>uatlib</code> as a submodule:</p>
<div class="fragment"><div class="line">git submodule add https://github.com/drone-comp/uatlib.git</div>
</div><!-- fragment --><p><code>uatlib</code> contains some third-party dependencies that are included as submodules as well. To initialize these submodules, run:</p>
<div class="fragment"><div class="line">git submodule update --init --recursive</div>
</div><!-- fragment --><p>Now, we can create a minimal C++20 program that uses <code>uatlib</code>. Create a new file called <code>main.cpp</code> in the <code>uatlib-tutorial</code> directory with the following contents:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="simulation_8hpp.html">uat/simulation.hpp</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>Point {</div>
<div class="line">  std::size_t x, y;</div>
<div class="line">  <span class="keyword">auto</span> operator==(<span class="keyword">const</span> Point&amp; other) <span class="keyword">const</span> noexcept -&gt; <span class="keywordtype">bool</span> {</div>
<div class="line">    <span class="keywordflow">return</span> x == other.x and y == other.y;</div>
<div class="line">  }</div>
<div class="line">  <span class="keyword">auto</span> operator!=(<span class="keyword">const</span> Point&amp; other) <span class="keyword">const</span> noexcept -&gt; <span class="keywordtype">bool</span> {</div>
<div class="line">    <span class="keywordflow">return</span> !(*<span class="keyword">this</span> == other);</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;&gt; <span class="keyword">struct </span>std::hash&lt;Point&gt; {</div>
<div class="line">  <span class="keyword">auto</span> operator()(<span class="keyword">const</span> Point&amp; p) <span class="keyword">const</span> noexcept -&gt; std::size_t {</div>
<div class="line">    <span class="keywordtype">size_t</span> seed = 0;</div>
<div class="line">    boost::hash_combine(seed, p.x);</div>
<div class="line">    boost::hash_combine(seed, p.y);</div>
<div class="line">    <span class="keywordflow">return</span> seed;</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">  uat::simulate&lt;Point&gt;();</div>
<div class="line">}</div>
<div class="ttc" id="asimulation_8hpp_html"><div class="ttname"><a href="simulation_8hpp.html">simulation.hpp</a></div><div class="ttdoc">Defines the simulation function and related types.</div></div>
</div><!-- fragment --><p>To describe our simulation, we first need to describe the type that represents the locations in the airspace. In the example above, we use a simple <code>Point</code> structure with <code>x</code> and <code>y</code> coordinates.</p>
<p>The library requires that your custom type satisfies <code>uat::region_compatible</code>, which is a concept that requires the type to be hashable, equality comparable, and copyable.</p>
<p>The <code>std::hash</code> specialization and the operators <code>==</code> and <code>!=</code> are required to use <code>Point</code> as a key in a <code>std::unordered_map</code> implicitly created by the library.</p>
<p>The <code>main</code> function calls the <code>simulate</code> function with <code>Point</code> as the template argument. This function runs the simulation with the given type representing the locations in the airspace.</p>
<p>As you should have noticed, this simulation does not do anything yet. In the next sections, we will describe how to create agents to participate in the auction.</p>
<p>Before we continue, let's create a <code>CMakeLists.txt</code> file in the <code>uatlib-tutorial</code> directory:</p>
<div class="fragment"><div class="line">cmake_minimum_required(VERSION 3.10)</div>
<div class="line"> </div>
<div class="line">project(uatlib-tutorial)</div>
<div class="line"> </div>
<div class="line">add_subdirectory(uatlib)</div>
<div class="line"> </div>
<div class="line">add_executable(uatlib-tutorial main.cpp)</div>
<div class="line">target_link_libraries(uatlib-tutorial PRIVATE uatlib)</div>
<div class="line">target_compile_features(uatlib-tutorial PRIVATE cxx_std_20)</div>
</div><!-- fragment --><p>This file tells CMake to build the <code>uatlib-tutorial</code> executable from the <code>main.cpp</code> file and link it with the <code>uatlib</code> library. The library requires C++20 features, so we set the compile features accordingly.</p>
<p>Now, we can build the project:</p>
<div class="fragment"><div class="line">cmake -H. -Bbuild</div>
<div class="line">cmake --build build</div>
</div><!-- fragment --><p>If everything goes well, you should see the <code>uatlib-tutorial</code> executable in the <code>build</code> directory. Running this executable should not produce any output yet.</p>
<p>Tip: Add the following line to your <code>.gitignore</code> file to ignore the <code>build</code> directory:</p>
<div class="fragment"><div class="line">build</div>
</div><!-- fragment --><p>Do not forget to add and commit the changes to the repository:</p>
<div class="fragment"><div class="line">git add main.cpp CMakeLists.txt .gitignore</div>
<div class="line">git commit -m &quot;First commit.&quot;</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md5"></a>
Creating agents</h1>
<p>In this section, we will create agents that participate in the auction. Agent implementations must inherit from the <code><a class="el" href="structuat_1_1agent.html" title="Class to define the default behavior of an agent.">uat::agent</a></code> class template, satisfy <code>std::movable</code> and implement a few methods.</p>
<p>Let's create a simple agent that have a few goals in the airspace and bid for permits to use them. Add the following code to the <code>main.cpp</code> file before the <code>main</code> function:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>Agent : <span class="keyword">public</span> <a class="code" href="structuat_1_1agent.html">uat::agent</a>&lt;Point&gt; {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  Agent(<span class="keywordtype">int</span> seed) {</div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">auto</span> <a class="code" href="structuat_1_1agent.html#a322c990fe9ce829a749c2cc521e4eab1">stop</a>(<a class="code" href="type_8hpp.html#a598a59e264c02aabe15cf4917348a005">uat::uint_t</a> time, <span class="keywordtype">int</span> seed) -&gt; <span class="keywordtype">bool</span> <span class="keyword">override</span> {</div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  std::unordered_set&lt;Point&gt; goals_;</div>
<div class="line">  std::unordered_set&lt;uat::permit&lt;Point&gt;&gt; owned_;</div>
<div class="line">  <a class="code" href="type_8hpp.html#addcf59e929a27563458b64c94da0b620">uat::value_t</a> cost_ = 0;</div>
<div class="line">};</div>
<div class="ttc" id="astructuat_1_1agent_html"><div class="ttname"><a href="structuat_1_1agent.html">uat::agent</a></div><div class="ttdoc">Class to define the default behavior of an agent.</div><div class="ttdef"><b>Definition:</b> agent.hpp:67</div></div>
<div class="ttc" id="astructuat_1_1agent_html_a322c990fe9ce829a749c2cc521e4eab1"><div class="ttname"><a href="structuat_1_1agent.html#a322c990fe9ce829a749c2cc521e4eab1">uat::agent::stop</a></div><div class="ttdeci">virtual auto stop(uint_t time, int seed) -&gt; bool=0</div></div>
<div class="ttc" id="atype_8hpp_html_a598a59e264c02aabe15cf4917348a005"><div class="ttname"><a href="type_8hpp.html#a598a59e264c02aabe15cf4917348a005">uat::uint_t</a></div><div class="ttdeci">std::size_t uint_t</div><div class="ttdoc">Default unsigned integer type.</div><div class="ttdef"><b>Definition:</b> type.hpp:29</div></div>
<div class="ttc" id="atype_8hpp_html_addcf59e929a27563458b64c94da0b620"><div class="ttname"><a href="type_8hpp.html#addcf59e929a27563458b64c94da0b620">uat::value_t</a></div><div class="ttdeci">double value_t</div><div class="ttdoc">Default type for price.</div><div class="ttdef"><b>Definition:</b> type.hpp:35</div></div>
</div><!-- fragment --><p>So, the <code>Agent</code> class inherits from <code><a class="el" href="structuat_1_1agent.html" title="Class to define the default behavior of an agent.">uat::agent</a>&lt;Point&gt;</code>. The only required method to implement is the <code>stop</code> method, which is called every iteration of the simulation. An agent that returns true from the <code>stop</code> method is removed from the simulation.</p>
<p>Our <code>Agent</code> class has three private members: <code>goals_</code>, <code>owned_</code>, and <code>cost_</code>. The <code>goals_</code> member is a set of points that represent the goals of the agent. The <code>owned_</code> member is a set of permits that the agent has successfully acquired. The <code>cost_</code> member is the total cost of the permits that the agent has acquired minus the earnings from the permits that the agent has sold.</p>
<p>Note that <code>goals_</code> contains only regions of the airspace that the agent is interested in. The agent will bid for permits to use these regions for different periods of time, depending when the agent enters the auction.</p>
<p>On the other hand, <code>owned_</code> contains elements of type <code><a class="el" href="structuat_1_1permit.html" title="A tuple containing a region and a time step.">uat::permit</a></code>, which is just a structure that holds the region and the time period that the agent has acquired.</p>
<p>Do not forget to include the necessary headers:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;unordered_set&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;jules/base/random.hpp&gt;</span></div>
</div><!-- fragment --><p>To implement the constructor and the <code>stop</code> method, we are going to use <a href="https://github.com/verri/jules">jules</a>, a header-only library that provides a random number generator and a few other utilities. It is already included as a submodule in <code>uatlib</code>.</p>
<p>Change the <code>CMakelists.txt</code> file to include the <code>jules</code> library:</p>
<div class="fragment"><div class="line">target_link_libraries(uatlib-tutorial PRIVATE uat jules)</div>
</div><!-- fragment --><p>Let's implement the constructor and the <code>agent::stop</code> method:</p>
<div class="fragment"><div class="line">Agent(<span class="keywordtype">int</span> seed) {</div>
<div class="line">  <span class="comment">// Let&#39;s consider the airspace as a 3x3 grid.</span></div>
<div class="line">  jules::random_engine rng(seed);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">while</span> (goals_.size() &lt; 3) {</div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> x = rng.uniform_index_sample(3u);</div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> y = rng.uniform_index_sample(3u);</div>
<div class="line">    goals_.insert({x, y});</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> stop(<a class="code" href="type_8hpp.html#a598a59e264c02aabe15cf4917348a005">uat::uint_t</a> time, <span class="keywordtype">int</span> seed) -&gt; <span class="keywordtype">bool</span> <span class="keyword">override</span> {</div>
<div class="line">  <span class="keywordflow">return</span> goals_.size() == owned_.size();</div>
<div class="line">}</div>
</div><!-- fragment --><p>Our simple agent is created with three random goals in a 3x3 grid. The agent stops when it has acquired permits for all its goals.</p>
<p>But how an agent can acquire permits? The library provides a method two methods to control the actions of the agents: <code>agent::bid_phase</code> and <code>agent::ask_phase</code>. These methods are optional. If the user does not implement them, the agent won't do anything at that phase.</p>
<p>The <code>bid_phase</code> method is called in the beginning of each time step. In this method, the agent can bid for permits to use the regions of the airspace at certain time that it is interested in. All bids are processed using a first-price sealed-bid auction. Then, the agent can decide to sell permits that it owns using the <code>ask_phase</code> method.</p>
<p>Let's implement the <code>bid_phase</code> method:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> bid_phase(<a class="code" href="type_8hpp.html#a598a59e264c02aabe15cf4917348a005">uat::uint_t</a> time, <a class="code" href="agent_8hpp.html#aa6cc312381ee9681e69b305bc27f095f">uat::bid_fn</a> bid, <a class="code" href="agent_8hpp.html#a6d6d92b91508d0212656ac48f2bc90d3">uat::permit_public_status_fn</a> status, <span class="keywordtype">int</span> seed) -&gt; <span class="keywordtype">void</span> <span class="keyword">override</span> {</div>
<div class="line">  <span class="comment">// Check at which time all goals are available.</span></div>
<div class="line">  <a class="code" href="type_8hpp.html#a598a59e264c02aabe15cf4917348a005">uat::uint_t</a> target_time = time + 1;</div>
<div class="line">  <span class="keywordflow">while</span> (<span class="keyword">true</span>) {</div>
<div class="line">    <span class="keywordtype">bool</span> all_goals_available = <span class="keyword">true</span>;</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; goal : goals_) {</div>
<div class="line">      <span class="keywordflow">if</span> (not std::holds_alternative&lt;uat::permit_public_status::available&gt;(status(goal, target_time))) {</div>
<div class="line">        all_goals_available = <span class="keyword">false</span>;</div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">if</span> (all_goals_available)</div>
<div class="line">      <span class="keywordflow">break</span>;</div>
<div class="line">    ++target_time;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  jules::random_engine rng(seed);</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; goal : goals_)</div>
<div class="line">    bid(goal, target_time, rng.canon_sample());</div>
<div class="line">}</div>
<div class="ttc" id="aagent_8hpp_html_a6d6d92b91508d0212656ac48f2bc90d3"><div class="ttname"><a href="agent_8hpp.html#a6d6d92b91508d0212656ac48f2bc90d3">uat::permit_public_status_fn</a></div><div class="ttdeci">std::function&lt; permit_public_status_t(region_view, uint_t)&gt; permit_public_status_fn</div><div class="ttdoc">Function type that returns the public status of a permit.</div><div class="ttdef"><b>Definition:</b> agent.hpp:57</div></div>
<div class="ttc" id="aagent_8hpp_html_aa6cc312381ee9681e69b305bc27f095f"><div class="ttname"><a href="agent_8hpp.html#aa6cc312381ee9681e69b305bc27f095f">uat::bid_fn</a></div><div class="ttdeci">std::function&lt; bool(region_view, uint_t, value_t)&gt; bid_fn</div><div class="ttdoc">Function type that allows the agent to bid for a permit.</div><div class="ttdef"><b>Definition:</b> agent.hpp:51</div></div>
</div><!-- fragment --><p>In this function, we first find the time at which all goals are available. Then, we bid for permits to use the regions of the airspace at that time. The bid amount is a random number between 0 and 1 generated by the <code>jules::random_engine</code> object.</p>
<p>The <code>bid</code> function (with type <code>uat::bid_fn</code>) is called with the region, the time, and the bid amount. The <code>status</code> function (with type <code>uat::permit_public_status_fn</code>) return the status of the permit at the given region and time (check the <code>permit_public_status_t</code> variant for the possible values).</p>
<p>Now, let's implement the <code>ask_phase</code> method:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> ask_phase(<a class="code" href="type_8hpp.html#a598a59e264c02aabe15cf4917348a005">uat::uint_t</a> time, <a class="code" href="agent_8hpp.html#a936f1e5c470a7759770616787913cc10">uat::ask_fn</a> ask, <a class="code" href="agent_8hpp.html#a6d6d92b91508d0212656ac48f2bc90d3">uat::permit_public_status_fn</a> status, <span class="keywordtype">int</span>) -&gt; <span class="keywordtype">void</span> <span class="keyword">override</span> {</div>
<div class="line">  <span class="keywordflow">if</span> (owned_.size() == goals_.size())</div>
<div class="line">    <span class="keywordflow">return</span>; <span class="comment">// Do not sell permits if all goals are achieved.</span></div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; [location, time] : owned_)</div>
<div class="line">    ask(location, time, 0);</div>
<div class="line">  owned_.clear();</div>
<div class="line">}</div>
<div class="ttc" id="aagent_8hpp_html_a936f1e5c470a7759770616787913cc10"><div class="ttname"><a href="agent_8hpp.html#a936f1e5c470a7759770616787913cc10">uat::ask_fn</a></div><div class="ttdeci">std::function&lt; bool(region_view, uint_t, value_t)&gt; ask_fn</div><div class="ttdoc">Function type that allows the agent to ask for a permit.</div><div class="ttdef"><b>Definition:</b> agent.hpp:54</div></div>
</div><!-- fragment --><p>In this function, we sell permits that we own. We do not sell permits if all goals are achieved. Otherwise, we put the permits on sale with a minimum price of 0.</p>
<p>Note that we clear the <code>owned_</code> set after selling the permits. We do not actually stop owning the permits, but we have not any interest in them anymore. The reason for this is that once we reach the ask phase and we have not achieved all goals, it means that our bids were not successful.</p>
<p>How do we know if the agent has acquired a permit? The library provides two callbacks that are called when a permit is acquired or sold: <code>agent::on_bought</code> and <code>agent::on_sold</code>. These methods are optional. If the user does not implement them, the agent react when a permit is acquired or sold but the book in the simulation will still consider the permits as owned by the agent.</p>
<p>Let's implement them:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> on_bought(<span class="keyword">const</span> Point&amp; location, <a class="code" href="type_8hpp.html#a598a59e264c02aabe15cf4917348a005">uat::uint_t</a> time, <a class="code" href="type_8hpp.html#addcf59e929a27563458b64c94da0b620">uat::value_t</a> cost) -&gt; <span class="keywordtype">void</span> <span class="keyword">override</span> {</div>
<div class="line">  owned_.insert({location, time});</div>
<div class="line">  cost_ += cost;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> on_sold(<span class="keyword">const</span> Point&amp; location, <a class="code" href="type_8hpp.html#a598a59e264c02aabe15cf4917348a005">uat::uint_t</a> time, <a class="code" href="type_8hpp.html#addcf59e929a27563458b64c94da0b620">uat::value_t</a> revenue) -&gt; <span class="keywordtype">void</span> <span class="keyword">override</span> {</div>
<div class="line">  <span class="comment">// We have already cleared the owned_ set in the ask_phase method.</span></div>
<div class="line">  <span class="comment">// No need to remove the permit from the set here.</span></div>
<div class="line">  cost_ -= revenue;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Now, we can build the project again:</p>
<div class="fragment"><div class="line">cmake --build build</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md6"></a>
Running the simulation</h1>
<p>Well... now we have a simple agent, but we need to add it to the simulation.</p>
<p>Let's change the <code>main</code> function to create a factory that creates instances of our agent for each iteration of the simulation:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">  uat::simulate&lt;Point&gt;({</div>
<div class="line">    .factory = [](<a class="code" href="type_8hpp.html#a598a59e264c02aabe15cf4917348a005">uat::uint_t</a> time, <span class="keywordtype">int</span> seed) -&gt; std::vector&lt;uat::any_agent&gt; {</div>
<div class="line">      <span class="comment">// Create 10 agents at time 0.</span></div>
<div class="line">      <span class="keywordflow">if</span> (time &gt; 0)</div>
<div class="line">        <span class="keywordflow">return</span> {};</div>
<div class="line"> </div>
<div class="line">      std::vector&lt;uat::any_agent&gt; agents;</div>
<div class="line">      std::mt19937 rng(seed);</div>
<div class="line"> </div>
<div class="line">      <span class="keywordflow">while</span> (agents.size() &lt; 10)</div>
<div class="line">        agents.push_back(Agent(rng()));</div>
<div class="line"> </div>
<div class="line">      <span class="keywordflow">return</span> agents;</div>
<div class="line">    }</div>
<div class="line">  });</div>
<div class="line">}</div>
</div><!-- fragment --><p>The <code>simulate</code> function now receives a configuration object with a <code>factory</code> field. This field is a function that receives the current time and a seed and returns a vector of <code><a class="el" href="classuat_1_1any__agent.html" title="A type-erased class that represents an agent in the simulation.">uat::any_agent</a></code>. The function is called at the beginning of each iteration of the simulation. The type <code><a class="el" href="classuat_1_1any__agent.html" title="A type-erased class that represents an agent in the simulation.">uat::any_agent</a></code> is a type-erased wrapper around derivations of <code><a class="el" href="structuat_1_1agent.html" title="Class to define the default behavior of an agent.">uat::agent</a></code>.</p>
<p>What about the stop condition? By default, the simulation stops when all agents return true from the <code>stop</code> method. If you want to change this behavior, take a look at the <code>uat::simulate</code> function documentation.</p>
<p>Now, build the project again and run the simulation:</p>
<div class="fragment"><div class="line">cmake --build build</div>
<div class="line">./build/uatlib-tutorial</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md7"></a>
Tracking trades</h1>
<p>The library provides a way to track the trades that occur during the simulation.</p>
<p>Let's change the <code>main</code> function to track the trades:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;fmt/core.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">  uat::simulate&lt;Point&gt;({</div>
<div class="line">    .factory = [](<a class="code" href="type_8hpp.html#a598a59e264c02aabe15cf4917348a005">uat::uint_t</a> time, <span class="keywordtype">int</span> seed) -&gt; std::vector&lt;uat::any_agent&gt; {</div>
<div class="line">      <span class="comment">// ...</span></div>
<div class="line">    },</div>
<div class="line">    .trade_callback = [](<a class="code" href="structuat_1_1trade__info__t.html">uat::trade_info_t&lt;Point&gt;</a> trade) -&gt; <span class="keywordtype">void</span> {</div>
<div class="line">      <span class="keywordflow">if</span> (trade.from == uat::no_owner)</div>
<div class="line">        fmt::print(<span class="stringliteral">&quot;@{}: agent {} bought permit at ({}, {}, {}) for {}\n&quot;</span>,</div>
<div class="line">                   trade.transaction_time, trade.to,</div>
<div class="line">                   trade.location.x, trade.location.y, trade.time, trade.value);</div>
<div class="line">      <span class="keywordflow">else</span></div>
<div class="line">        fmt::print(<span class="stringliteral">&quot;@{}: agent {} bought permit at ({}, {}, {}) for {} from agent {}\n&quot;</span>,</div>
<div class="line">                   trade.transaction_time, trade.to,</div>
<div class="line">                   trade.location.x, trade.location.y, trade.time,</div>
<div class="line">                   trade.value, trade.from);</div>
<div class="line">    }</div>
<div class="line">  });</div>
<div class="line">}</div>
<div class="ttc" id="astructuat_1_1trade__info__t_html"><div class="ttname"><a href="structuat_1_1trade__info__t.html">uat::trade_info_t</a></div><div class="ttdoc">Type to represent the information in a trade transaction.</div><div class="ttdef"><b>Definition:</b> simulation.hpp:24</div></div>
</div><!-- fragment --><p>We have used the <code>fmt</code> library to format the output (which also is a dependency of <code>uatlib</code>). You can add it to the <code>CMakeLists.txt</code> file:</p>
<div class="fragment"><div class="line">target_link_libraries(uatlib-tutorial PRIVATE uat jules fmt)</div>
</div><!-- fragment --><p>This should be enough to have a simple simulation of a first-price sealed-bid auction. You can now experiment with different strategies for the agents and analyze the results.</p>
<p>Let's run:</p>
<div class="fragment"><div class="line">cmake --build build</div>
<div class="line">./build/uatlib-tutorial</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
